## 正式环境服务端渲染开发也就是正式环境开发 ssr.js
主要流程已经在server-render.js中写好了,ssr中需要引入一些依赖

## 1. package.json
```json
    "build:server": "cross-env NODE_ENV=production webpack --config build/webpack.config.server.js",

    "build": "npm run clean && npm run build:client && npm run build:server",

    "clean": "rimraf dists && rimraf server-build",

```

## 2.git-ignore
node_modules
dist
server-build  // 构建出来的文件


## 3.npm run build 进行打包
生成server-build/vue-ssr-bundle.js
开发时候从内存读取，正式环境中从磁盘读
vue的源码作为externals 没有打包在内，减少体积
externals: Object.keys(require('../package.json').dependencies),

## 4.编写正是环境 ssr.js
```javascript
const serverRender = require('./server-render')
const Router = require('koa-router')
const VueServerRenderer = require('vue-server-renderer')
const path = require('path')
const fs = require('fs')
// json文件可以作为模块require
const clientManifest = require('../../dists/vue-ssr-client-manifest.json')

// const VueCLientPlugin = require('vue-server-renderer/client-plugin')此插件生成
const renderer = VueServerRenderer.createBundleRenderer(
  path.json(__dirname, '../../server-build/vue-ssr-server-bundle.json'), {
    inject: false,
    clientManifest

  }
)
// 模版文件
const template = fs.readFileSync(
  path.join(__dirname, '../server-template.ejs'),
  'utf-8'
)
const pageRouter = new Router()

pageRouter.get('*', async (ctx) => {
  await serverRender(ctx, renderer, template)
})

module.exports = pageRouter


```

## 5.修改server.js

```javascript
let pageRouter
if (isDev) {
  pageRouter = require('./routers/dev-ssr')
} else {
  pageRouter = require('./routers/ssr')
}
app.use(async (ctx, next) => {
  if (ctx.path === '/favicon.ico') {
    // 上层目录的文件 异步请求
    await send(ctx, '/favicon.ico', { root: path.join(__dirname, '../')})
  } else {
    await next()
  }
})
app.use(pageRouter.routes()).use(pageRouter.allowedMethods())
```

## 6.修改正式环境命令
使用已经build好的文件
   "start": "cross-env NODE_ENV=production node server/server.js"

正是环境下不需要等webpack编译，已经build好了

## 6. 文件请求错误

```javascript
GET http://127.0.0.1:8001/public/0.css net::ERR_CONNECTION_REFUSED
localhost/:155 GET http://127.0.0.1:8001/public/3.2ad0b6e7.js net::ERR_CONNECTION_REFUSED
localhost/:8 GET http://127.0.0.1:8001/public/3.css net::ERR_CONNECTION_REFUSED
3localhost/:155 GET http://127.0.0.1:8001/public/runtime~main.864e157d.js net::ERR_CONNECTION_REFUSED
localhost/:1 GET http://127.0.0.1:8001/public/resourses/client/assets/images/beijing-e7746a9f.jpg net::ERR_CONNECTION_REFUSED

```

正式请求服务的时候没有webpack-dev-server， 正是环境打包使用的output路径还是127.0.0.1， 所以请求静态资源路径错误

修改webpack.config.client, 打包使用绝对路径，域名端口去掉
```javascript
// 正是环境下
修改前
    output: {
      filename: '[name].[chunkhash:8].js'
    },
修改后
    output: {
      filename: '[name].[chunkhash:8].js',
      publicPath: '/public/'
    },
```
打包完成后路径会变为/public/

## 7.服务端处理路径
创建 routers/static
```javascript
const Router = require('koa-router')
const send = require('koa-send')

// 这个router 只能处理 /public 路径
const staticRouter = new Router({ prefix: '/public' })

// 请求路径为 /public
staticRouter.get('/*', async ctx => {
  await send(ctx, ctx.path)
})

module.exports = staticRouter

```

## 8.现在打包输出路径为dist
修改为public

修改webpack.config.base.js

```javascript
  output: {
    // 输出路径
    filename: 'bundle.[hash:8].js',
    path: path.join(__dirname, '../public'),
    publicPath: 'http://127.0.0.1:8001/public/'
  },
```

## 9. 修改package.json 

"clean": "rimraf public && rimraf server-build",


## 10.修改server/routers/ssr.js

// json文件可以作为模块require
const clientManifest = require('../../public/vue-ssr-client-manifest.json')


## 11.在server.js中使用
```javascript
const staticRouter = require('./routers/static')

app.use(staticRouter.routes()).use(staticRouter.allowedMethods())
let pageRouter

```

npm run build

