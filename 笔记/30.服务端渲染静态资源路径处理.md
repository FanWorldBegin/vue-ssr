## 1.页面中生成的script标签
```javascript
<script src="/public/bundle.ba0092c3.js" defer=""></script>
<script src="/public/0.bundle.ba0092c3.js" defer=""></script>
```
是在server-render中 生成的
```javascript
const html = ejs.render(template, {
  // 渲染template 需要的变量
  appString,
  // 拿到带有标签的整个字符串
  style: context.renderStyles(),
  scripts: context.renderScripts()
})

```

在dev-ssr.js中调用 server-render

clientManifest 是通过webpack-dev-server 请求过来的
```javascript
  const clientManifestResp = await axios.get(
    'http://127.0.0.1:8001/public/vue-ssr-client-manifest.json'
  )

  const clientManifest = clientManifestResp.data
  const template = fs.readFileSync(
    path.join(__dirname, '../server.template.ejs'),
    'utf-8'
  )
  // 1.传入bundle 会生成一个可以执行render 的function
  const renderer = VueServerRenderer
    .createBundleRenderer(bundle, {
      inject: false, // 按照官方规定的模版可以直接注入（这里不要）
      clientManifest // 生成有js标签的字符串
    })

  await serverRender(ctx, renderer, template)
```
## 2. node端没有处理localhost:3333下的这几个路径

<script src="/public/bundle.ba0092c3.js" defer=""></script>
<script src="/public/0.bundle.ba0092c3.js" defer=""></script>

报错： no component matched

所有的请求都到服务端渲染 dev-ssr中，服务端渲染，把路径再传到入口文件server-entry.js,   router.push(context.url) 将路径push到router中，但router是静态资源文件，没有这个路径，需要在客户端做相应的映射。加载对应客户端的JS

1. 可以在server中开启一个代理，将 /public/ 路径代理到 webpack-dev-server

2. 方法2：设置webpack.config.base.js
   将静态资源路径指定为完整的Url，只能到http://127.0.0.1:8000，webpack dev server去请求静态资源，
   这样即便是在3333端口访问服务，但页面请求的静态资源标签也会带有前缀，还是会访问到webapck-dev-server

   ```javascript
  output: {
    // 输出路径
    filename: 'bundle.[hash:8].js',
    path: path.join(__dirname, '../dists'),
    publicPath: 'http://127.0.0.1:8000/public/'
  },

   ```
   

  此时查看源码发现加载的script标签路径改变
  <script src="http://127.0.0.1:8001/public/bundle.f4dcb100.js" defer=""></script>
<script src="http://127.0.0.1:8001/public/0.bundle.f4dcb100.js" defer=""></script>


发现页面正常显示


## 3.处理 request with the path /favicon.ico 问题
在根目录放一个favicon.ico

安装 包发送静态资源文件
npm i koa-send -S

### 2.打开server.js
使用中间件

```javascript
const send = require('koa-send')
const path = require('path')

app.use(async (ctx, next) => {
  if (ctx.path === '/favicon.ico') {
    // 上层目录的文件 异步请求
    await send(ctx, '/favicon.ico', { root: path.join(__dirname, '../')})
  } else {
    await next()
  }
})

就可以获取到了
```

## 3. 修改后自动更新
创建nodemon.json
npm i nodemon -D

1.   "restartable": "rs" 命令行输入 rs 可以自动重启
2.   ignore 忽略一些文件的修改，默认监听所有文件，客户端下
```javascript
{
  "restartable": "rs", 
  "ignore": [
    ".git",
    "node_modules/**/node_mudules",
    ".eslintrc",
    "client",
    "build/webpack.config.client",
    "public"
  ],
  "verbose": true,
  "env": {
    "NODE_ENV": "development",
    "ext": "js json ejs"
  }
}

```

## 4. 修改启动命令
    "dev:server": "nodemon server/server.js"

## 5. 使用工具一次启动两个服务
npm i concurrently -D

修改package.json
   "dev": "concurrently \"npm run dev:client\" \"npm run dev:server\" "

这样只需要运行 npm run dev 就能启动两个服务


## 5. 报错
vue.runtime.esm.js?2b0e:619 [Vue warn]: Cannot find element: #root

客户端渲染到#root节点上
服务端渲染返回的html 没有root 节点

在server.template.ejs 中加入root节点
```javascript
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title></title>
  <%- style %>
</head>
<body>
  <div id="root"> <%- appString %></div>

  <%- scripts %>
</body>
</html>
```
