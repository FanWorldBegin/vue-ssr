# 真正的服务端渲染操作
封装到单独的js里面

## 1. 创建server-render.js
创建基本流程
```javascript
// 服务端渲染操作
const ejs = require('ejs')
module.exports = async (ctx, renderer, template) => {
  // 设置请求头
  ctx.headers['Content-Type'] = 'text/html'

  // 传入 vue-server-render来渲染html
  // 包括客户端js路径，css路径，vue当前路由样式内容
  const context = { url: ctx.path }

  try {
    const appString = await renderer.renderToString(context) // 这个方法返回promise
    // 渲染html
    const html = ejs.render(template, {
      // 渲染template 需要的变量
      appString,
      // 拿到带有标签的整个字符串
      style: context.renderStyles(),
      scripts: context.renderScripts()
    })

    ctx.body = html // 返回html
  } catch (err) {
    // 打印错误
    console.log('render err', err)
    throw err
  }
}

```

## 2.编辑server.template.ejs
补齐模版   <%-  防止转译
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <%- style %>
</head>
<body>
  <%- appString %>

  <%- scripts %>
</body>
</html>

```
以上nodeJS端内容， 接下来 server-entry-js(客户端入口文件)

## 2.创建 client/create-app.js
每次服务端渲染，都要渲染一个新的·app，不能用上一次渲染过的对象，会影响小次渲染的内容。
```javascript
import Vue from 'vue'
import VueRouter from 'vue-router'
import Vuex from 'vuex'

import App from './app.vue'

import createStore from './store/store'
import createRouter from './config/router'

import './assets/styles/global.styl'
Vue.use(VueRouter)
Vue.use(Vuex)

// m每次返回新对象，避免在node端出现内存溢出情况
export default () => {
  const router = createRouter()
  const store = createStore()

  const app = new Vue({
    router,
    store,
    render: h => h(App)
  })

  return { app, router, store }
}

```

## 3.clent/server-entry.js

每次创建新的对象
```javascript
import { createApp } from './create-app'

// context 为 serve-render.js 中的 renderer.renderToString中的传入的 context
// 在这里接收
export default context => {
  return new Promise((resolve, reject) => {
    const { app, router, store } = createApp()
    // router.push 给路由添加对象，主动匹配路由调用组件,根据Url匹配组件
    router.push(context.url)

    // 路由中所有异步操作做完后做这个回调
    router.onReady(() => {
      // 在服务端渲染时候，亚要做异步请求，需要匹配组件
      const matchedComponents = router.getMatchedComponents()
      if (!matchedComponents.length) {
        return reject(new Error('no component Matched'))
      }

      resolve(app)
    })
  })
}

```

## 4.启动服务端渲染package.json

"dev:server": "cross-env NODE_ENV=development node server/server.js"

## 5. 调试代码

### 1. server.js 监听端口
```javascript
const Koa = require('koa')

const app = new Koa()

// 区分开发环境和生产环境
const isDev = process.env.NODE_ENV === 'development'

// 中间件 记录请求和错误信息
app.use(async (context, next) => {
  try {
    console.log(`request with the path ${context.path}`)
    await next()
  } catch (err) {
    console.log(err)
    context.state = 500
    if (isDev) {
      context.body = err.message
    } else {
      // 生产环境
      context.body = 'please try later'
    }
  }
})

const HOST = process.env.HOST || '0.0.0.0'
const PORT = process.env.PORT || 3333

app.listen(PORT, HOST, () => {
  console.log(`server is listening on ${HOST}:${PORT}`)
})

```

运行 npm run dev:server
    npm run dev:client

### 2.dev-ssr.js 处理所有请求
```javascript
// 获取webpack 配置

// node 目前不支持import
const Router = require('koa-router')
const axios = require('axios')
const MemoryFS = require('memory-fs')
const webpack = require('webpack')

const path = require('path')
const fs = require('fs')
// 服务端渲染
const VueServerRenderer = require('vue-server-renderer')

++ const serverRender = require('./server-render')
const serverConfig = require('../../build/webpack.conifg.server')
// 1.nodejs里面编译webpack, 可以生成一个在服务端运行的bundle - serverCompiler，可以直接run

const serverCompiler = webpack(serverConfig)
// 2.指定输出方式。
// MemoryFS 不把文件写入磁盘，（不生成新文件） 存储在内存中，这样webpack读取会很快
const mfs = new MemoryFS()

serverCompiler.outputFileSystem = mfs // 指定输出目录在memoryFS里面

let bundle // 用来记录webpack打包文件

// 3. 在client目录下修改文件后，会重新执行打包
serverCompiler.watch({}, (err, states) => {
  if (err) throw err // 打包错误，抛出错误
  states = states.toJson()

  // 当不是打包错误（eslint）不会出现在err里面，会出现在states里
  status.erros.forEach(err => console.log(err))
  status.hasWarnings.forEach(warn => console.warn(warn))
  // 以上为webpack相关配置

  // 获取输出路径
  const boundlePath = path.join(
    // 2.输出目录为webpack 中指定的 ../server-build
    serverConfig.output.path,
    // 使用插件生成的json
    'vue-ssr-server-bundle.json'
  )
  // 读出字符串而不是二进制utf-8
  bundle = JSON.parse(mfs.readFileSync(boundlePath, 'utf-8'))
  console.log('new bundle generated')
})



++++++++++++++++++++++++++++++++++
// koa 的中间件，处理服务端渲染返回的东西
const handleSSR = async (ctx) => {
  // 第一次打包bundle可能不存在
  if (!bundle) {
    ctx.body = '等一会别着急......'
    return
  }

  const clientManifestResp = await axios.get(
    'http:127.0.0.1:8000/vue-ssr-cient-manifest.json'
  )

  const clientManifest = clientManifestResp.data
  const template = fs.readFileSync(
    path.join(__dirname, '../server.template.ejs')
  )
  // 1.传入bundle 会生成一个可以执行render 的function
  const renderer = VueServerRenderer
    .createBundleRenderer(bundle, {
      inject: 'false', // 按照官方规定的模版可以直接注入（这里不要）
      clientManifest // 生成有js标签的字符串
    })

  await serverRender(ctx, renderer, template)
}

const router = new Router()

// 所有请求都通过 handleSSR处理
router.get('*', handleSSR)

module.exports = router


```

### 3. 在server.js 中使用 router
