## 1. module
this.$store.state.a.text 根据命名空间
添加作用域 store.js
```javascript
const isDev = process.env.NODE_ENV === 'development'
export default () => {
  return new Vuex.Store({
    // strict: true, // 禁止直接修改state
    strict: isDev,
    state: defaultState,
    mutations: mutations,
    getters,
    actions,
    modules: {
      a: {
        state: {
          text: 1
        }
      },
      b: {
        state: {
          text: 2
        }
      }
    }
  })
}

```
app.vue

```javascript
computed: {
  textA () {
    return this.$store.state.a.text  // 引用方法1
  },
  textB () {
    return this.$store.state.b.text
  },
  // ...mapState(['count']),
  ...mapState({
    count: 'count',
    counter: (state) => state.count 
    textA: state => state.a.text // 引用方法2
  }),
},
```

## 2. 模块内的mutation
1. store.js
```javascript
modules: {
  a: {
    state: {
      text: 1
    },
    mutations: {
      updateText (state, text) {
        // state 为 a模块的state
        state.text = text
      }
    }
  },
  b: {
    state: {
      text: 2
    }
  }
}
```

2. app.vue
mutation 默认注册在全局， 可以直接使用
```javascript
methods: {
  ...mapActions(['updateCountAsync']),
  ...mapMutations(['updateCount', 'updateText'])
},
mounted () {
  this.updateText('123')
}
```

## 3.为mutation添加自己的命名空间
namespaced: true, 将mutation 注册在模块下

1. strore.js
```javascript
modules: {
  a: {
    namespaced: true,
    state: {
      text: 1
    },
    mutations: {
      updateText (state, text) {
        // state 为 a模块的state
        state.text = text
      }
    }
  }
}
```

2. app.vue
使用变量方式调用
```javascript
methods: {
  ...mapActions(['updateCountAsync']),
  ...mapMutations(['updateCount', 'a/updateText'])
},
mounted () {
  this['a/updateText']('123')
}
```

## 4. 模块下的getters
参数
getters: 所有的getter方法
rootState: 全局的state

1. store.js 
```javascript
modules: {
  a: {
    namespaced: true,
    state: {
      text: 1
    },
    mutations: {
      updateText (state, text) {
        // state 为 a模块的state
        state.text = text
      }
    },
    getters: {
      textPlus (state, getters, rootState) {
        return state.text + rootState.count + rootState.b.text
      }
    }
  },
}
```

2. app.vue

```javascript
// 这样写不方便在template 中直接使用
computed: {
  ...mapGetters(['fullName', 'a/textPlus'])

},

// 调用
this['a/textPlus']  ===> 1231


...mapGetters({
  fullName: 'fullName',
  textPlus: 'a/textPlus'
})
```

## 5.命名空间下的action
commit  的为当前模块的mutation，而不是全局的
```javascript
mutations: {
  updateText (state, text) {
    // state 为 a模块的state
    state.text = text
  }
},
actions: {
  add ({ state, commit, rootState }) {
    // context 模块的
    commit('updateText', rootState.count)
  }
}
```

##  6.commit 全局的 mutation
添加 root: true 
1. store.js
```javascript
modules: {
  a {
    namespaced: true,
    state: {
      text: 1
    },
    mutations: {
      updateText (state, text) {
        // state 为 a模块的state
        state.text = text
      }
    },
    actions: {
      add ({ state, commit, rootState }) {
        // context 模块的
        commit('updateText', rootState.count)
        // 调用全局参数
        commit('updateCount', { num: 1, num2: 2 }, { root: true })
      }
    }
  }
}
```
2. 调用 app.vue
```javascript
methods: {
  ...mapActions(['updateCountAsync', 'a/add']),
  ...mapMutations(['updateCount', 'a/updateText'])
},

// 调用
this['a/add']()
```
## 7. commit其他模块的mutation
注意 在没有 namespace 属性时候可以不写root: true, 也可以取到其他模块
1. store.js

```javascript

a: {
  namespaced: true,
  state: {
    text: 1
  },
  mutations: {
    updateText (state, text) {
      // state 为 a模块的state
      state.text = text
    }
  },
},
b: {
  state: {
    text: 2
  },
  actions: {
    // 调用模块a的 mmutation
    textActions ({ commit }) {
      commit('a/updateText', 'test test', { root: true })
    }
  }
}

```

2. app.vue
```javascript
  methods: {
    // textActions 为 模块B的，B没有nameSpace
    ...mapActions(['updateCountAsync', 'a/add', 'textAction']),
    ...mapMutations(['updateCount', 'a/updateText'])
    
    // 调用
    this.textAction();
  },

```

## 8. 模块里可以接着添加模块

## 9. 动态注册模块

使用router异步加载功能，有一个模块，只在异步加载时用到，其余地方用不到。把这部分代码拆分到异步加载模块，需要store 提供动态注册模块功能，

entry.js

```javascript
const store = createStore() // 创建store

store.registerModule('C', {
  state: {
    text: 3
  }
})


app.vue 中调用

...mapState({
  count: 'count',
  counter: (state) => state.count, // 可以进行计算
  textC: state => state.c.text
}),
```

## 10.模块添加热更新功能
每次修改代码后不需要页面刷新就能看到改变
store.js
```javascript
import Vuex from 'vuex'
import defaultState from './state/state'
import mutations from './mutations/mutations'
import getters from './getters/getters'
import actions from './action/action'
const isDev = process.env.NODE_ENV === 'development'
export default () => {
  const store = new Vuex.Store({
    // strict: true, // 禁止直接修改state
    strict: isDev,
    state: defaultState,
    mutations: mutations,
    getters,
    actions,
    modules: {
    }
  })
  // webpack热更新代码
  if (module.hot) {
    module.hot.accept([
      // 对应配置的引入地址
      './state/state',
      './mutations/mutations',
      './getters/getters',
      './action/action'

    ], () => {
      // 代码内部不能使用import
      const newState = require('./state/state').default
      const newMutations = require('./mutations/mutations').default
      const newGetters = require('./getters/getters').default
      const newAction = require('./action/action').default
      store.hotUpdate({
        state: newState,
        mutations: newMutations,
        getters: newGetters,
        action: newAction
      })
    })
  }
  return store
}

```
