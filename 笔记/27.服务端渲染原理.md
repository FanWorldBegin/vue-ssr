
# 服务端渲染

## 1. 服务端渲染流程
![原理图](https://github.com/FanWorldBegin/vue-ssr/blob/master/images/27.1.jpeg)

1. 需要有server端，启动webpack dev server 8000端口， dev server 是一个自主server，没法添加服务端渲染代码，需要再启动加 nodeJS server。
2. node server 执行服务端渲染逻辑，使用vue-server-render包再nodejs 环境中渲染出vue代码生成·的html代码，可以直接在浏览器看
3. 是有2个服务的webpack dev server， 服务端渲染， server 3333端口。 
4. 直接访问webpack dev server 就走前端渲染，加载js new vue 对象，渲染页面
5. 服务端渲染流程，访问3333端口，做服务端渲染，也要打包vue应用的代码逻辑，打包出来的代码不是运行在浏览器端，而是运行在node端。
6. 需要进行两个不同的webpack打包，node端打包出来的代码要在node端使用。
7. 在node server中直接启动一个webpack server compiler。
8. webpack可以直接作为模块被引入nodejs， 通过compiler 直接生成一个server bundle（服务端的app.js）
9. 两个打包出来的代码是有区别的， node server 中可以获取的server bundle，执行node server render 渲染出html 代码返回给用户，不需要通过js 渲染html内容。
10. 拿到前端流程打包出来的 app.js css 样式等静态资源文件路径，插入 server bundle 渲染出html。
11. 服务端渲染值渲染

## 2.建立webpack配置文件，打包服务端代码
webpack.config.server.js



## 7.创建client/server-entry.js

### 1.入口出口
```javascript
// 根据配置项合理合并
const config = merge(baseConfig, {
  entry: path.join(__dirname, '../client/server-entry.js'), // 1.入口
  target: 'node', // ++ 2. 定义打包出来node运行环境
  // 调试代码，可以在浏览器里面看到自己写的代码, 而不是打包后的
  devtool: 'source-map', // ++3. 可以调试代码
  output: {
    libraryTarget: 'commonjs2', // 4. 在服务度端运行，指定代码export出去入口怎样
    // nodejs 是module.exports =  引用出去nodejs可以直接引用
    filename: 'server-entry.js', // 5. 指定名字，不需要哈希模块加载
    path: path.join(__dirname, '../server-build'), // 6.制定输出路径
    externals: Object.keys(require('../package.json').dependencies)
    // 7.由于程序跑在node端，不需要把vue代码打包到输出文件中，只需要require就可以 (npm i vue -D)
},
```

### 2.样式style文件要单独打包到一个文件中
style-loader会把css通过javascript引用dom方式插入HTML，会有Dom操作的代码在里面，在node中会报错。node中没有dom

```javascript
  rules: [
    {
      test: /\.styl(us)?$/,
      use: [
        {
          loader: MiniCssExtractPlugin.loader
        },
        {
          loader: 'postcss-loader',
          options: {
            // stylus-loader 会生成sourceMap 直接使用他生成的，提高效率
            sourceMap: true
          }
        },
        'stylus-loader'
      ]
    }
  ]
```

### 3. plugins

```javascript
  plugins: [
    new MiniCssExtractPlugin({
      // Options similar to the same options in webpackOptions.output
      // all options are optional
      filename: '[name].css',
      chunkFilename: '[id].css',
      ignoreOrder: false // Enable to remove warnings about conflicting order
    }),
    // make sure to include the plugin for the magic
    // 可以在页面中获取变量进行判断,js 中可以获取，区别打包
    // 要单引号在外面，获取到是字符串
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'),
      'process.env.VUE_ENV': "'server"
    })
  ]

```

## 4. 添加一个重要插件
帮我们生成单独的json文件，用于在服务端渲染中处理逻辑。
npm i vue-server-renderer -S
```javascript
const VueServerPlugin = require('vue-server-renderer/server-plugin')
  plugins: [
    new MiniCssExtractPlugin({
      // Options similar to the same options in webpackOptions.output
      // all options are optional
      filename: '[name].css',
      chunkFilename: '[id].css',
      ignoreOrder: false // Enable to remove warnings about conflicting order
    }),
    // make sure to include the plugin for the magic
    // 可以在页面中获取变量进行判断,js 中可以获取，区别打包
    // 要单引号在外面，获取到是字符串
    new webpack.DefinePlugin({
      'process.env.NODE_ENV': JSON.stringify(process.env.NODE_ENV || 'development'),
      'process.env.VUE_ENV': "'server"
    }),
    new VueServerPlugin()
  ]
```
打包会生成一个json文件

